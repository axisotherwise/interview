# 자바스크립트
<br>

### ESM CJS
1. ESM <br>
ES6 모듈 방식입니다. <br>
import/export로 모듈들을 가져오고 내보내는 방식입니다. <br>

2. CJS <br>
CommonJS 모듈 방식입니다. <br>
require/exports로 모듈들을 가져오고 내보내는 방식입니다. <br>

* ESM은 strict 모드가 기본적으로 설정돼있고 번들링 시 파일 크기가 커지지 않습니다. <br>
* CJS는 strict 모드를 걸어주어야 하고 번들링 시 파일의 크기가 커집니다. <br>
* 대체로 ESM 모듈을 사용하나 CJS 모듈을 사용했던 프로젝트들도 있어 둘 다 효과적으로 사용할 수 있어야 합니다. <br>

<br>

### var let const
> var는 함수 스코프이며 let과 const는 블록 스코프입니다. <br>
> var는 호이스팅의 특성이 있으며 재선언과 재할당이 가능합니다. <br>
> let은 재선언이 불가능하고 재할당만 가능합니다. <br>
> const는 재선언 재할당이 불가능합니다. <br>

<br>

### 원시 타입 참조 타입
1. 원시 타입 <br>
불변 값이며 데이터가 변수에 할당되면 메모리 상에 고정된 크기로 저장되고 해당 변수가 원시 데이터 값을 보관합니다. <br>

<br>

2. 참조 타입 <br>
가변 값이며 데이터 크기는 정해져 있지 않고 변수에 할당되면 직접 변수에 저장되는 게 아니라 데이터에 대한 주소만 저장됩니다. <br>

<br>

### 스코프
식별자에 접근할 수 있는 범위입니다. <br>

* 스코프 체인이란 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해 나가는 과정입니다. <br>

<br>

### 얕은 복사 깊은 복사
1. 얕은 복사 <br>
참조 타입 데이터가 저장한 메모리 주소 값을 복사합니다. <br>
원본 값과 복사된 값이 같은 메모리 주소를 가리키며 복사된 값이 수정될 경우 원본 값도 수정됩니다. <br>

2. 깊은 복사 <br>
새로운 메모리 공간을 확보해 완전히 복사합니다. <br>
복사된 데이터가 다른 주소를 참조하며 내부의 값을 복사합니다.

새로운 메모리 공간을 확보해 원본의 내부값을 복사합니다. <br>
복사된 값이 원본 값과 다른 주소를 가르킵니다.

<br>

### 콜 스택 메모리 힙
1. 콜 스택 <br>
원시 타입 데이터가 저장됩니다. <br>
실행 컨텍스트를 통해 변수 식별자를 저장하고 디스와 코드 실행 순서 관리를 수행합니다. <br>

<br>

2. 메모리 힙 <br>
참조 타입 데이터가 저장되며 메모리 할당이 일어나는 공간입니다. <br>

* 크기는 런타임 단계에서 동적으로 결정되므로 힙은 구조화되어있지 않습니다. <br>

<br>

### 이벤트 루프
libuv 내부에 비동기 논 블로킹 작업을 가능하게 해주는 구현체입니다. <br>
비동기 방식으로 동시성을 지원합니다. <br>

<br>

### 동기 비동기
실행과 동시에 결과값이 기대되는 경우를 동기 그렇지 않은 경우 비동기라고 합니다. <br>

1. 동기 <br>
직렬적으로 실행되며 하나의 작업이 끝날 시점까지 다음 작업은 대기해야 하며 기존 작업이 종료되어야 실행될 수 있습니다. <br>

<br>

2. 비동기 <br>
병렬적으로 실행되며 하나의 작업의 완료 여부와 관계없이 다음 작업이 실행될 수 있습니다. <br>

<br>

### 블로킹 논 블로킹
코드의 실행이 다른 코드의 실행을 막냐 막지않느냐로 구분합니다. <br>

1. 블로킹 <br>
기존 작업이 다음 작업을 블로킹하는 걸 의미합니다. <br>

<br>

2. 논 블로킹 <br>
기존 작업이 다른 작업을 막지 않으므로 논 블로킹입니다. <br>

<br>

### 프로미스
내용은 실행되었지만 결과를 반환하지 않은 객체입니다. <br>
then을 만나기 전까지 동기적으로 실행되며 resolve와 reject는 각각 성공 실패를 의미합니다. <br>
콜백과 다르게 실행할 함수를 분리할 수 있어 사용하고자 하는 시점에 사용할 수 있습니다. <br>

<br>

### async await
프로미스의 단점을 보완한 문법이며 비동기 코드를 동기 코드처럼 작성할 수 있습니다. <br>

* 프로미스와의 차이점으로는 에러 핸들링과 코드 가독성의 차이가 있습니다.

<br>

### 콜백 함수
함수의 파라미터로 전달받은 함수를 의미합니다. <br>
제어권은 전달된 함수에게 있으며 비동기 프로그래밍의 방식의 문제점을 해결할 수 있지만 콜백 지옥과 에러 처리에 어려움이 있습니다. <br>

<br>

### 콜백 지옥
콜백 함수가 반복되어 코드의 들여 쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 의미합니다. <br>

### this
실행되는 주체에 따라 동적으로 변하는 자기 참조 변수입니다. <br>

1. 전역 공간에서의 this는 전역 객체에 바인딩됩니다. <br>
2. 메서드로 호출되는 this는 메서드 호출 주체에 바인딩 됩니다. <br>
3. 함수로써 호출되는 this는 전역 객체로 바인딩되며 메서드 내부 함수에서도 동일합니다. <br>
4. 콜백 함수 내부에서 호출되는 경우 제어권을 넘겨받은 함수가 정의한 주체에 바인딩되며 정의하지 않은 경우 전역 객체에 바인딩됩니다. <br>
5. 생성자 함수에서의 this는 생성될 인스턴스에 바인딩됩니다. <br>

<br>

### TDZ
let 또는 const 또는 함수 표현식 선언 시 선언 이전에 식별자를 참조할 수 없는 구역을 의미합니다. <br>

* var function import는 호이스팅되므로 TDZ에 해당되지 않습니다. <br>

<br>

### 호이스팅
코드 실행 시 변수와 함수의 선언을 스코프 최상단으로 끌어올리는 걸 의미합니다. <br>

* var와 함수 선언문에서 발생하며 let과 const 함수 표현식에서는 발생하지 않습니다. <br>
* var는 선언과 동시에 초기화가 이루어지므로 undefined가 할당됩니다. <br>

<br>

### undefined null
undefined와 null 모두 값이 없음을 나타냅니다. <br>
명시적으로 없음을 나타내야 한다면 null을 사용해야 합니다. <br>

* typeOf null은 object인데 이 현상은 자바스크립트 설계 에러이며 일치 연산자를 활용해 검사해야 합니다. <br>

<br>

### 실행 컨텍스트
실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다. <br>

활성화 되는 시점에 variableEnvironment와 lexicalEnvironment와 thisBinding을 수집합니다. <br>

* 실행 컨텍스트 생성 시 variableEnvironment와 lexicalEnvironment는 동일한 내용으로 구성되지만 lexicalEnvironment는 variableEnvironment와 다르게 변경 사항이 실시간으로 반영됩니다. <br>

* 실행 컨텍스트 생성 시 variableEnvironment에 정보(식별자와 외부 환경 정보)들을 먼저 담은 다음 이를 그대로 복사해 lexicalEnvironment를 만들고 이후에는 lexicalEnvironment를 주로 활용합니다. <br>

* variableEnvironment와 lexicalEnvironment는 environmentRecord와 outerEnvironmentReference로 구성되어있습니다. <br>

* environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됩니다. <br>


