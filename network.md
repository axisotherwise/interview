# 네트워크
<br>

### CORS
서로 다른 오리진에서 데이터의 송수신을 허용하는 보안 정책입니다. <br>
콜스 에러란 SOP(Same Origin Policy)가 다른 경우 정책에 위반되어 브라우저에서 발생시키는 에러입니다. <br>

* 서버에서 응답 헤더에 특정 헤더를 포함하는 방식으로 해결할 수 있습니다. <br>
* 단순 요청은 GET POST HEAD <br>
* 사전 요청은 OPTIONS 메서드를 사용해 실제 요청을 보내기 전 해당 리소스에 요청이 가능한지 확인하는 요청입니다. <br>

<br>

### 메서드
* REST API 관점에서 POST를 제외한 메서드는 멱등 해야 합니다. <br>

1. GET <br>
리소스를 조회할 경우 사용합니다. <br>
주소에 데이터를 담아 보낼 수 있으며 길이의 제한이 있습니다. <br>
데이터는 주소에 노출되므로 민감한 정보를 포함해서는 안 됩니다. <br>

<br>

2. POST <br>
리소스를 생성할 경우 사용합니다. <br>
데이터는 바디에 담아 보낼 수 있으며 길이의 제한이 없습니다. <br>

<br>

3. PUT <br>
리소스가 있다면 대체하고 없으면 생성합니다. <br>

<br>

4. PATCH <br>
PUT과 특징은 동일하지만 PATCH는 리소스의 일부만 변경합니다. <br>

<br>

5. DELETE <br>
리소스를 제거합니다.

<br>

### GIT
형상 관리를 위해 사용합니다. <br>

* 형상 관리란 소프트웨어의 변경 사항을 체계적으로 추적하고 통제함을 의미합니다. <br>

GIT 브랜치 전략 중 하나인 GIT 플로우를 사용합니다. <br>
크게 5개의 브랜치를 관리합니다. <br>

* main 현재 배포되어 있는 프로덕션 브랜치 <br>
* develop 다음 버전 출시를 위한 브랜치 <br>
* feature 기능 개발을 위한 브랜치 (기능 완료 후 삭제) <br>
* release 테스트를 위한 브랜치 <br>
* hotfix 버그 수정을 위한 브랜치 <br>

<br>

### XSS CSRF
브라우저에서 스크립트를 실행할 수 있는 코드를 삽입해 공격자가 의도한 스크립트를 실행하게 하는 해킹 공격입니다. <br>

* 둘의 차이는 공격이 실행되는 위치이며 XSS는 사용자 CSRF는 서버입니다. <br>

<br>

### 프록시
대리인의 개념입니다. <br>
클라이언트와 서버 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 응용 프로그램을 의미합니다. <br>

<br>

### WEB WAS
1. WEB <br>
정적 리소스를 제공하고 리버스 프록시를 구성해 WAS 서버에 대한 정보를 숨겨 서버의 보안성을 높일 수 있습니다. <br>

* 요청 인자 값에 따라 리소스가 변경되지 않습니다. <br>

2. WAS <br>
대부분의 WAS 서버는 기본적으로 WEB 서버의 기능을 포함하고 있습니다. <br>

* 요청 인자 값에 따라 리소스가 변경될 수 있습니다. <br>

<br>

### 쿠키
1. 쿠키 <br>
브라우저 접속 시 생성되는 Key-Value 형태로 구성된 임시 파일입니다. <br>
브라우저에 저장되므로 수정과 삭제가 가능하며 제3자에 의해 탈취될 수 있습니다. <br>

<br>

2. 세션 <br>
사용자로부터 일정 시간 동안 들어오는 요청을 하나의 상태로 보고 해당 상태를 유지시키는 기술입니다. <br>

* 서버에 저장되어 쿠키에 비해 보안적으로 안전하지만 서버에서 다시 세션을 참조해야하므로 사용자가 늘어날 수록 부하가 발생합니다. <br>

<br>

### 토큰
안전하게 데이터를 송수신 하기 위해 JSON 형태로 된 Claim 기반의 웹 토큰입니다. <br>
토큰은 서명되어 있어 신뢰할 수 있으며 필요한 정보를 자체적으로 지니고 있는 자가 수용적 특징이 있습니다. <br>

1. 헤더 <br>
토큰의 종류와 서명 알고리즘을 정의합니다. <br>

<br>

2. 페이로드 <br>
사용자의 엔티티 만료 기간 등을 정의합니다. <br>

<br>

3. 시그니처 <br>
헤더와 페이로드를 인코딩(Base64) 하며 토큰에 대한 유효성을 검증할 수 있습니다. <br>
인코딩 된 값은 서명된 알고리즘으로 해싱 후 다시 인코딩되어 생성됩니다. <br>

<br>

### OAUTH
사용자들이 사용 서비스에 새롭게 정보를 제공하지 않고 기존에 다른 웹 사이트에 저장돼있는 자신의 정보에 대한 접근 권한을 부여할 수 있도록 사용되는 방식입니다. <br>

<br>

### 세션 토큰
1. 세션 <br>
클라이언트 요청 시 클라이언트의 정보를 서버에 저장하므로 StateFul 구조입니다. <br>

2. 토큰 <br>
클라이언트 요청 시 클라이언트의 정보를 서버에 저장하지 않으므로 Stateless 구조입니다. <br>

<br>

* 세션은 단일 도메인의 경우 적합합니다. <br>
* 세션에 사용되는 쿠키는 단일(서브) 도메인에 작동하도록 설계되어 있습니다. <br>

<br>

### REST
자원을 이름으로 구분해 해당 자원의 상태를 주고받는 아키텍처 스타일입니다. <br>
자원과 행위 그리고 표현으로 구성되어 있으며 웹의 기술과 HTTP 프로토콜을 사용합니다. <br>

* 자원은 HTTP URL로 구분합니다. <br>
* 행위는 HTTP Method로 구분합니다. <br>
* 표현은 주고받는 데이터의 형식을 의미합니다. <br>

<br>

### REST API
REST의 특징으로 구성된 API를 의미합니다. <br>
각 요청이 어떤 동작이나 정보를 의미하는지 요청의 모습 자체로 추론이 가능해야 합니다. <br>

* URL에서 접근하는 리소스에 대해 명확하게 표현해야 합니다. <br>
* 표현하는 리소스에 동사가 들어가면 안 됩니다. <br>
* 자원은 URL로 행위는 Method로 결과는 상태 코드로 확인할 수 있습니다. <br>

### HTTP 프로토콜
서버/클라이언트의 구조를 따르며 데이터를 송수신하기 위한 규칙입니다. <br>

1. 무상태성 <br>
클라이언트 요청에 대한 상태를 저장하지 않습니다. (Stateless)

<br>

2. 비연결성 <br>
요청에 맞는 응답이 종료되면 연결을 끊습니다. (ConnectionLess)

<br>

### HTTP HTTPS
1. HTTP <br>
TCP와 직접 통신하며 데이터는 평문으로 송수신됩니다. <br>
제3자에 의해 조회될 수 있습니다. 

<br>

2. HTTPS <br>
HTTP는 SSL과 SSL은 TCP와 통신하며 데이터는 암호화되어 송수신됩니다. <br>
제3자에 의해 조회당하더라도 암호화 키가 탈취되지 않는 이상 조회한 데이터를 복호화 할 수 없습니다. <br>

<br>

### TCP UDP
1. TCP <br>
데이터 송수신을 위해 IP를 이용하는 연결 지향형 프로토콜입니다. <br>

* 3-way-handshake를 통해 연결하고 4-way-handshake를 통해 연결을 해제합니다. <br>
* 오류와 혼잡 제어가 가능합니다. <br>

2. UDP <br>
비연결형 프로토콜입니다. <br>
통신 간에 신뢰성을 보장하지 않으며 IP를 그대로 사용해 단순 CheckSum 말고는 데이터의 훼손을 감지할 수 없습니다. <br>
중간에 데이터가 유실되어도 다시 요청할 수 있는 방법이 없습니다. <br>

* 오류 제어와 혼잡 제어가 불가능합니다. <br>

### URI URL
1. URI <br>
네트워크 상의 자원을 나타내는 고유한 통합 식별자입니다. <br>

* 리소스를 고유하게 식별합니다. <br>

2. URL <br>
네트워크 상의 자원의 위치를 나타냅니다 <br>
리소스가 어디 있고 어떻게 접근할 수 있는지를 의미합니다. <br>

<br>

### 대칭키 비대칭키
1. 대칭키 <br>
데이터를 암호화/복호화 하는 데 있어 사용되는 키가 하나입니다. <br>

<br>

2. 비대칭키 <br>
대칭키와 반대로 암호화/복호화에 사용되는 키가 2개입니다. (개인키/공개키)

<br>

### 3-way-handshake
TCP/IP 프로토콜을 이용해 통신하는 응용 프로그램이 데이터를 송수신하기 전 신뢰성 있는 전송을 보장하기 위해 사전에 상대방 컴퓨터와 세션을 수립하는 과정을 의미합니다. <br>

1. 클라이언트는 서버로 SYN 플래그를 보냅니다. <br>
2. 서버는 클라이언트에게 SYN과 ACK 플래그를 보냅니다. <br>
3. 클라이언트는 서버에게 ACK 플래그를 보내면서 연결이 이루어집니다. <br>

<br>

### 4-way-handshake
TCP/IP 프로토콜 연결을 종료하기 위해 클라이언트와 서버가 연결된 세션을 종료하는 과정을 의미합니다. <br>

1. 클라이언트는 서버에게 FIN 플래그를 보냅니다. <br>
2. 서버는 클라이언트에게 ACK 플래그를 보내고 연결 종료 시까지 기다립니다. <br>
3. 연결 종료 후 서버는 클라이언트에게 FIN 플래그를 보냅니다. <br>
4. 클라이언트는 서버에게 ACK 플래그를 보내며 연결이 종료됩니다. <br>

* 3번에서 서버와 클라이언트 통신이 종료되는 과정에서 플래그보다 데이터가 늦게 도착할 경우 Packet 유실이 발생하는데 이 과정을 방지하기 위해 Time-Wait이 존재합니다. <br>

<br>

### 프로세스와 스레드
1. 프로세스 <br>
컴퓨터에 저장돼있는 프로그램이 메모리에 올라가 인스턴스화됨을 의미합니다. <br>

* 실행되는 프로그램과 프로그램이 실행되는 주변 환경을 의미합니다. <br>

2. 스레드 <br>
프로세스 내부에서 자원을 공유하며 실행되는 작업의 단위를 의미합니다. <br>

<br>

### 크롬 탭
탭 별로 렌더링 정보와 기타 데이터를 가지고 있으므로 개별 프로세스입니다. <br>
하나의 탭에 문제가 생겨도 다른 탭의 영향을 주지 않습니다. <br>

<br>

### OSI 7계층
네트워크 통신 과정을 계층별로 개념화한 모델을 의미합니다. <br>

1. 물리 계층 <br>
전기적 데이터의 전송을 담당합니다. <br>
데이터의 내용이 뭔지 에러가 발생했는지 등에 통신 내용은 관여하지 않습니다. <br>

* 전송 단위는 Bit이며 통신 케이블과 허브를 사용합니다. <br>

2. 데이터 링크 계층 <br>
물리 계층을 통해 송수신되는 데이터의 오류와 흐름을 관리하고 안전한 데이터의 전달을 수행합니다. <br>
시스템들 간의 신뢰성을 보장하며 재전송의 기능도 수행합니다. <br>

* 전송 단위는 Frame이며 브릿지와 스위치를 사용하고 Ethernet 프로토콜을 사용합니다. <br>

3. 네트워크 계층 <br>
논리적인 주소 체계와 라우팅을 지원합니다. <br>
데이터가 원하는 목적지까지 성공적으로 전달될 수 있도록 합니다. <br>

* 전송 단위는 Packet이며 라우터를 사용하고 IP ICMP ARP 프로토콜을 사용합니다. <br>

<br>

4. 전송 계층 <br>
프로세스 간의 통신을 담당하며 포트 번호를 정의하고 오류 및 흐름 제어 다중화를 수행합니다. <br>

* 전송 단위는 Segment이며 TCP/UDP를 사용하고 게이트 L4 프로토콜을 사용합니다. <br>

5. 세션 계층 <br>
응용 프로세스가 통신을 관리하기 위한 방법을 제공합니다. <br>
동시 송수신(Duplex)과 반이중(Half Duplex)과 전이중(Full Duplex) 통신를 포함합니다. <br>
네트워크의 사이에 상호작용을 설정/유지하며 동기화의 역할을 수행합니다. <br>

* 체크 포인트를 설정하여 전송 도중 연결이 끊어지거나 충돌이 발생하면 마지막 체크 포인트에서 세션을 재개합니다. <br>
* 전송 단위는 데이터이며 NetBIOS SSH TLS 프로토콜을 사용합니다. <br>

6. 표현 계층 <br>
서로 다른 데이터 표현 방식을 사용하는 응용 프로세스가 잘 통신할 수 있도록 데이터 형식과 표현을 다루는 역할을 수행합니다. <br>
세션 계층에서 받은 데이터를 응용 계층으로 보내기 전 적절한 데이터의 형태로 변환시킵니다. <br>

* 전송 단위는 데이터이며 ASCII JPEG MPEG 프로토콜을 사용합니다. <br>

7. 응용 계층 <br>
소프트웨어 사용자와의 인터페이스를 담당합니다. <br>
응용 프로세스와 직접 관계하여 일반적으로 수행되는 응용 서비스를 수행합니다. <br>

* 전송 단위는 데이터이며 DNS FTP HTTP 프로토콜을 사용합니다. <br>

<br>

### base64
바이너리 데이터를 텍스트로 변환하는 인코딩 방법 중 하나입니다. <br>

* 바이너리 데이터를 Character Set에 영향을 받지 않는 공통 ASCII 영역의 문자로만 이루어진 문자열로 변환하는 과정입니다. <br>
* 인코딩을 하게 되면 전송해야 할 데이터의 크기는 30% 정도 증가합니다. <br>
* 6비트 당 2비트의 오버헤드가 발생합니다. <br>






