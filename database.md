# 데이터베이스
<br>

### 1. 데이터베이스 사용 이유
데이터베이스 사용 전 데이터는 파일 시스템을 통해 관리되었음. <br>
파일 시스템은 데이터에 대한 종속성 중복성 그리고 무결성의 문제가 있음. <br>

<br>

### 2. 데이터베이스 특징
1. 실시간 접근성 <br>
비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 함. <br>

2. 지속적인 변화 <br>
데이터베이스의 상태는 동적이며 새로운 데이터의 삽입 삭제 갱신으로 항상 최신 데이터를 유지해야 함. <br>

3. 동시 공용 <br>
데이터베이스는 서로 다른 목적을 가진 여러 응용자들이 사용함. <br>
그러므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함. <br>

4. 내용에 의한 참조 <br>
데이터베이스에 있는 데이터 참조 시 레코드의 주소나 위치에 의해서가 아니라 사용자가 정의하는 데이터의 내용으로 찾아져야 함. <br>

<br>

### 3. SQL
1. DDL(Data Definition Language) <br>
데이터베이스의 구조를 정의함. <br>
(Create, Drop, Alter, Truncate) <br>

2. DML(Data Manipulation Language) <br>
데이터의 조작을 위해 사용함. <br>
(Select, Insert, Update, Update) <br>

3. DCL(Data Controller Language) <br>
데이터 관리와 무결성 유지를 위해 사용함. <br>
(Grant, Revoke)

<br>

### 4. 이상 현상
올바르지 않은 테이블 설계로 인해 발생하는 논리적 오류를 의미함. <br>

1. 삽입 이상 <br>
자료 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상. <br>

2. 갱신 이상 <br>
중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상. <br>

3. 삭제 이상 <br>
어떤 데이터를 삭제하면 의도하지 않은 데이터까지 삭제되버리는 현상. <br>

<br>

### 5. 정규화
하나의 릴레이션에 하나의 의미만 갖도록 릴레이션을 분해하는 과정임. <br>
나쁜 릴레이션의 속성들을 나누어 좋고 작은 릴레이션으로 분해함. <br>
나쁜 릴레이션의 판단은 Entity를 구성하고 있는 속성 간에 함수적 종속성으로 판단함. <br>
판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용됨. <br>

함수적 종속성이란 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계를 속성 B는 속성 A에 종속을 의미함. <br>

장점 <br>
불필요한 데이터 제거와 이상 현상을 방지하기 위해 실행함.

단점 <br>
릴레이션의 분해로 인해 릴레이션 간의 연산이 많아져 성능 저하가 발생할 수 있음. <br>

<br>

### 6. 비정규화
하나 이상의 테이블에 데이터를 중복으로 배치하는 과정을 의미함. <br>
읽기 작업의 성능 문제가 발생한 경우 성능을 개선하기 위해 사용함. <br>
과도한 비정규화는 데이터의 무결성이 조각 날 수 있음. <br>

<br>

### 7. SQL Injection
악의적인 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법임. <br>

1. 방지
사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값인지 검증해야 함. <br>

2. 저장 프로시저 사용
사용하고자 하는 쿼리의 형식을 지정하여 지정된 형식의 데이터가 아니면 쿼리가 실행되지 않도록 설정함. <br>

<br>

### 8. 트랜잭션
특정 작업이 모두 처리되거나 처리되지 않을 경우 실행 이전 상태로 복구하여 작업의 일부만 적용되지 않도록 하는 기능임. <br>

1. 원자성(Atomicity)
작업이 모두 반영되거나 반영되지 않아야 함.(All or Nothing) <br>

2. 일관성(Consistency)
트랜잭션이 완료되면 데이터베이스는 언제나 일관성 있는 상태를 유지해야 함. <br>

3. 독립성(Isolation)
둘 이상의 트랜잭션이 동시에 실행 시 서로는 서로의 작업에 끼어들 수 없음. <br>

4. 지속성(Durability)
트랜잭션이 완료되면 결과는 데이터베이스 영구적으로 반영되어야 함. <br>

* 트랜잭션 격리 수준 <br>
트랜잭션들끼리 얼마나 고립되었는지를 나타냄. <br>
서로 다른 트랜잭션끼리 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정함. <br>
일관성 즉 동시성 제어 문제를 해결하기 위해서 필요함. <br>

격리성이 완벽히 보장되려면 거의 순차적으로 실행되어져야하는데 이렇게 되면 성능이 매우 안좋아짐. <br>

이러한 문제로 트랜잭션 격리 수준을 4단계로 나눔 순서대로 격리 수준이 낮음<br>

1. 커밋되지 않은 읽기 <br>
트랜잭션에서 커밋되지 않은 데이터를 다른 트랜잭션이 접근이 가능한 현상을 의미함. <br>

* 더티 리드, 논 리피터블 리드, 팬텀 리드 현상 발생 <br>

2. 커밋된 읽기 <br>
트랜잭션에서 완료된 커밋만 다른 트랜잭션이 접근하는 게 가능함. <br>

* 논 리피터블, 팬텀 리드 현상 발생 <br>

3. 반복 가능한 읽기 <br>
트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준임. <br>

* 팬텀 리드 현상 발생 <br>

4. Serializable 직렬화 기능 <br>
트랜잭션이 특정 테이블을 읽는 경우 공유 락을 걸어 다른 트랜잭션에서 해당 테이블의 데이터를 Insert, Update, Delete 작업을 못하도록 막음. <br>

동시 처리 능력이 다른 격리 수준보다 떨어지고 성능 저하가 발생하여 데이터베이스에서 거의 사용되지 않음. <br>

* 격리 수준에 따라 발생할 수 있는 문제 <br>
더티 리드: 트랜잭션이 완료되지않았음에도 다른 트랜잭션에서 볼 수 있는 현상 <br>
논 리피터블 리드: 한 트랜잭션 내에서 같은 쿼리가 2번 실행될 경우 그 사이에 트랜잭션이 값을 수정하거나 삭제함으로써 두 쿼리의 결과가 다른 비 일관성이 발생하는 현상을 의미함. <br>
팬텀 리드: 한 트랜잭션내에 동일한 쿼리를 두번 실행했을 경우 처음 쿼리에서 존재하지 않는 레코드가 2번째 쿼리에서 존재하는 현상. Insert에서만 발생함. 이를 방지하기 위해 베타락을 걸어야함. <br>

### 9. 락
1. 공유 락 <br>
읽기 작업 시 사용되는 락임. <br>
여러 사용자가 동시에 데이터를 읽어도 일관성에 영향을 주지 않으므로 동시에 접근 가능함. <br>
공유 락이 설정돼있는 데이터에 베타 락은 사용할 수 없음. <br>

2. 베타 락 <br>
데이터 변경 시 사용되는 락임. <br>
베타 락은 트랜잭션 완료 시까지 유지됨. <br>
베타 락이 해제될 시점까지 다른 트랜잭션은 해당 데이터에 접근할 수 없음. <br>

<br>

### 10. 정적 쿼리 동적 쿼리
1. 정적 쿼리
어떤 조건 또는 상황에도 변경되지 않는 쿼리임. <br>

2. 동적 쿼리
특정 조건 또는 상황에 따라 변경되는 쿼리임. <br>

<br>

### 11. 조인
테이블을 결합하는 연산 작업을 의미함. <br>
조인은 Inner 조인과 Outer 조인으로 나뉨. <br>

1. Inner Join (둘 다 만족하는 경우 출력)<br>
테이블 간 공통 컬럼을 이용하여 컬럼 값이 같은 레코드들을 출력하는 방법. <br>
조인 테이블 모두 레코드가 존재하는 경우 레코드가 반환됨. <br>

2. Outer Join (둘 다 만족하지 않으면 NULl로 출력)<br>
두 테이블에서 한쪽에만 레코드가 있고 다른 쪽에는 없는 경우 레코드가 존재하는 테이블의 레코드를 출력하는 방법임. <br>

- 왼쪽 테이블을 기준으로 검색하며 왼쪽 테이블의 레코드를 모두 출력하고 오른쪽 테이블에서는 조인 조건에 맞는 값들이 출력되며 왼쪽 테이블을 기준으로 오른쪽 테이블에 존재하지 않는 값은 NULL로 검색됨. <br>

<br>

### 12. 인덱스
데이터를 논리적으로 정렬하여 검색과 정렬 작업의 속도를 향상 시키는 자료 구조의 일종임. <br>
인덱스를 사용하면 풀 스캔이 아닌 레인지 스캔을함으로써 검색과 질의에 대한 처리가 빠르게 이루어짐. <br>
인덱스는 테이블 내의 여러개의 컬럼을 이용하여 생성할 수 있음. <br>

단점 <br>
데이터 조회 작업의 성능은 향상되지만 삽입 변경 등이 일어날 경우 매번 인덱스가 변경되므로 성능 저하가 발생할 수 있음. <br>

사용 <br>
크기가 큰 테이블에 사용함. <br>
한개의 테이블에 복수의 인덱스를 사용할 경우 성능이 저하될 수 있음. <br>
카디널리티가 높은 컬럼에 생성해야함 이유는 인덱스 트리를 따라가는데 조작이 증가해
오버헤드가 발생될 수 있음. <br>

카디널리티(Cardinality) <br>
유니크 값의 개수 성별 컬럼의 경우 카디널리티의 개수는 2임. <br>
주민등록번호는 레코드 수가 카디널리티 개수를 의미함 <br>

고려 사항 <br>
- 데이터가 적을수록 효율이 떨어짐. <br>
- 데이터의 유일성이 높고 범위가 높을수록 효율이 올라감. <br>
- NULL이 적은 컬럼의 효율적임. <br>

<br>

### 13. SQL NoSQL
1. SQL
관계형 데이터베이스로 스키마가 존재하며 모든 데이터를 2차원의 테이블 형태로 표현함. <br>

장점 <br>
구조화된 스키마로 데이터를 관리하므로 데이터의 정합성을 보장할 수 있음. <br>

단점 <br>
시스템이 커질수록 쿼리가 복잡해지고 성능이 저하되어 ScaleOut이 어려움(ScaleUp 가능) <br>

2. NoSQL
비관계형 데이터베이스로 스키마가 존재하지않고 데이터는 Key-Value 형태로 저장됨. <br>

장점 <br>
스키마가없어 데이터를 조회하고 삽입하는 성능이 좋음. <br>
데이터 분산이 용이하며 성능 향상을 위한 ScaleUp과 ScaleOut이 가능함. <br>

단점 <br>
명확한 데이터 구조를 보장하지않아 데이터 구조 결정이 어려움. <br>

사용 <br>
금융 결제와 같이 데이터 간 관계가 복잡하거나 무결성이 중요해 ACID 성질을 준수해야 한다면 SQL <br>
데이터 변경에 유연해야하거나 양이 많다면 NoSQL

<br>

### 14. Truncate Drop Delete
1. Truncate
테이블의 용량이 줄어들며 인덱스가 모두 삭제됨. <br>
테이블의 최초 생성된 초기 상태로 만듦. <br>
테이블은 삭제되지 않으며 데이터가 삭제되고 Rollback이 불가능함. <br>

2. Drop
테이블을 삭제하며 Rollback이 불가능함. <br>

3. Delete
데이터는 지워지지만 테이블의 용량은 줄어들지않음. <br>
원하는 데이터만 삭제할 수 있고 느리며 Rollback이 가능함. <br>

<br>

### 15. GROUP BY
GROUP BY 명령어를 통해 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹핑해주는 역할임. <br>
(COUNT, SUM, AVG, MAX, MIN)

<br>

### 16. WHERE HAVING
1. HAVING <br>
그룹화 또는 집계가 발생한 후 필터링하는데 사용됨.

2. WHERE <br>
그룹화 또는 집계가 발생하기 전 필터링하는데 사용됨.<br>

집계 함수(COUNT, SUM, AVG, MAX, MIN)는 HAVING 절과 사용할 수 있으나 WHERE는 불가능함. <br>
집계 함수를 사용할 수 있는 GROUP BY 절보다 WHERE 절이 먼저 실행됨.

<br>

### 17. JOIN ON과 WHERE 차이
ON이 WHERE보다 먼저 실행되어 JOIN을 하기 전 필터링 하고 WHERE 절은 JOIN을 한 후에 필터링을 함. <br>

<br>

### 18. 데이터베이스 무결성
1. 개체 무결성 (Entity Integrity) <br>
기본 키는 NULL 값이 올 수 없으며 중복될 수 없음. <br>

2. 참조 무결성 (Referential Integrity) <br>
외래 키는 NULL 값이 올 수 있으며 부모 테이블의 기본 키에 종속되어야 함. <br>

3. 도메인 무결성 (Domain Integrity) <br>
삽입될 수 있는 데이터의 제약 조건을 의미함. <br>

<br>

### 19. 쿼리 순서
SELECT ㅡ> FROM ㅡ> WHERE ㅡ> GROUP BY ㅡ> ORDER B

<br>

### 20. 옵티마이저
쿼리의 실행결과는 동일하지만 내부적으로 결과를 만들어내는 방법은 매우 다양함. <br>
다양한 방법 중 어떤 방법이 최적이고 최소 비용일지 결정해야함. <br>

쿼리를 최적으로 실행하기 위해 테이블에 데이터가 어떤 분포로 저장돼있는지를 참조하고
데이터를 기반으로 최적의 실행 계획을 수립해주는 게 옵티마이저임. <br>

쿼리 실행 절차 <br>
1. SQL 문을 잘게 쪼개서 MySQL Server가 이해할 수 있는 수준으로 분리(파스 트리)함. <br>
2. SQL의 분리(파스 트리) 정보를 확인해 어떤 테이블부터 읽고 어떤 인덱스를 이용할지 결정함. <br>
3. 2단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 Storage Engine에서 데이터를 가져옴. <br>

<br>

### 21. 데드락












