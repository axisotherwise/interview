# 프로젝트
<br>

### 0. 프로젝트에 대한 설명
이미지만 보고 만들 수 있는 홈 카페 레시피 공유 서비스입니다.

익스프레스 기반의 타입스크립트를 사용해 개발하였으며
디비는 관계형 데이터베이스인 MySQL을 사용하였습니다.

익스프레스와 NGINX를 각각 WEB과 WAS서버로 활용해 EC2에 배포하였습니다.

### 1. 프로젝트를 만들면서 가장 어려웠던 부분
이미지 리사이징 이슈입니다.

PNG 이미지 리사이징 시 특정 이미지에 대해 리사이징 전보다 리사이징 후의 용량이 증가하는 현상이 발생했습니다.

에러가 발생하는 게 아니어서 로그를 확인해 볼 수 없었으며 수집 장의 PNG 이미지를 대조하여 특정 이미지를 식별해 보려고 하였으나 원인을 알아낼 수 없었습니다.

혼자 고민해 진전이 없을 거라 판단하여 해당 이슈를 팀원과 공유하여 원인 파악의 범위를 좁혀나갔습니다.

팀원의 제안으로 공식 문서를 다시 읽어나가는 과정에서 JPG와 PNG의 이미지 압축 방식이 다르다는 점을 발견하고 이를 토대로 라이브러리 저장소에 이슈를 기재해 질문하여 해결할 수 있었습니다.

문제
PNG는 JPG와 다르게 8 비트 알파 채널을 지원해 다양한 투명도를 표현할 수 있습니다.
리사이징 과정에서 양자화가 일어나지 않으면 용량이 감소하지 않았습니다.
(양자화 옵션을 켜서 해결)

<br>

### 1. NGINX
이벤트 기반의 비동기 논 블로킹 웹 서버 소프트웨어임. <br>
하나의 마스터 프로세스와 여러 개의 워커 스레드로 구성되어 있음. <br>
서버 실행 시 스레드를 생성하여 클라이언트의 요청을 한정된 스레드 개수를 기반으로 처리함. <br>

- 정적 리소스 제공
- 리버스 프록시 구성
- 로드밸런서

Master Process는 설정 파일을 읽거나 검증하고 워커 스레드를 관리하는 역할을 수행함. <br>

Worker Process는 요청에 대한 작업을 수행하는 역할을 함. <br>

- 스레드가 적을 경우 작업을 처리함에 있어 스레드가 부족하여 성능 저하가 발생될 수 있음. <br>
- 스레드가 많을 경우 놀고 있는 스레드(IDLE)가 발생해 자원이 낭비될 수 있음. <br>
- 기본적으로 스레드는 개수는 서버 CPU 사양에 맞게 생성되며 직접 설정할 수 있음. <br> 
- 이벤트 루프를 통해 작업이 처리됨. <br>

<br>

### 2. Serverless
별도의 서버를 구축 관리할 필요 없이 코드를 실행할 수 있는 환경을 의미함. <br>
온 프레미스와 클라우드 구축 방식의 한계점을 보완할 수 있음. <br>

장점 <br>
- 별도의 서버를 관리할 필요가 없음.
- 사용한 만큼 비용을 지불함.(True On Demand)
- 인프라 차원에서 고가용성과 내구성이 확보됨.
- 배포 과정이 간단하므로 비즈니스 로직에만 집중 가능.

단점 <br>
- 콜드 스타트.
- 무상태성이므로 데이터 공유 불가능.
- 완성된 형태의 API를 받아 사용하므로 시스템 커스터마이징이 제한됨.
- 클라우드 서비스 업체에 대한 종속성.

1. Baas(Backend as a Service) <br>
완성된 형태의 API를 제공받아 사용하는 방식임. <br>

- 서비스에 필요한 기능들을 빠르고 쉽게 구현 가능함.
- 복잡한 서버 기능들을 직접 구현할 필요가 없음.

2. Faas(Function as a Service) <br>
필요한 기능을 직접 개발하여 알아서 호출 및 종료되도록 하는 방식임. <br>

- 작성한 함수를 등록함.

<br>

### 3. Lambda
독립적인 환경에서 실행되는 이벤트 중심의 컴퓨팅 서비스를 의미함. <br>

구성 <br>
1. Deployment Package
- 코드와 코드를 실행하기 위한 런타임임.
- 코드 용량 제한이 존재함.

2. 일반 구성
- 다른 AWS와 연결하기 위한 IAM 존재함.
- 메모리는 128~10,240MB 코드 하나에 최대 15분까지 실행 가능함.
- Trigger 방식으로 다른 서비스(API Gateway SQS S3) 호출

특징 <br>
- 운영 체제와 런타임에 구애받지 않음.
- 다양한 프로그래밍 언어 지원함.
- True On Demand 방식임.

장점 <br>
- True On Demand 방식이므로 경제적임.
- 별도의 서버를 관리할 필요가 없음.

단점 <br>
- 메모리와 처리 시간에 제한이 있음.
- 컨테이너 기반의 실행 환경이므로 무상태성임.
- 콜드 스타트.

<br>

작동 원리 <br>
handler는 4단계로 구분되어있음. <br>

1. Download Your Code
업로드 한 Deployment Package를 다운로드하는 단계임. <br>

2. Start New Execution Environment
코드가 런타임을 생성하는 단계임. <br>

3. Execute Initialization Code
handler 바깥의 전역 코드를 실행하는 단계임. <br>

4. Execute Handler Code
handler 내부 코드를 실행하는 단계임. <br>

handler의 event context <br>
1. event <br>
함수가 Invoke 될 경우 데이터를 수신받는 위치이며 어떤 서비스에 Invoke 되었는지에 따라 구조는 달라짐. <br>

- RequestResponse Invoke는 동기적으로 작동하며 응답값이 존재함.
- event Invoke는 비동기적으로 작동하며 응답값이 존재하지 않음.

2. context <br>
로깅 등의 용도로 사용할 수 있는 메타데이터가 수신됨. <br>

<br>

콜드 스타트 <br>
코드 실행 런타임이 구성되는 동안 발생하는 딜레이 현상을 의미함. <br>
일정 시간동안 실행되지않다가 실행되면 발생함. <br>

콜드 스타트 해결 방법 <br>
- 람다를 계속 호출함. 하지만 비용이 발생함. <br>
- 메모리의 사양을 올림. 비용이 발생함. <br>
- 프로비저닝 된 동시성 사용. 비용이 발생함. <br>








